#!/usr/bin/env bash

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !
# ! Note:
# !
# ! THIS SCRIPT HAS BEEN AUTOMATICALLY GENERATED USING 
# ! swagger-codegen-bash (github.com/bkryza/swagger-codegen-bash) 
# ! FROM SWAGGER SPECIFICATION IN JSON.
# !
# ! Generated on: {{generatedDate}}
# !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#
# This is a Bash client for {{appName}}. 
#
# LICENSE:
# {{licenseUrl}}
#
# CONTACT:
# {{infoEmail}}
#
# MORE INFORMATION:
# {{#externalDocs}}{{url}}{{/externalDocs}}
#


###############################################################################
# 
# Global variables
# 
###############################################################################

##
# The filename of this script for documentation
script_name=`basename "$0"`

##
# Map for headers passed after operation as KEY:VALUE
declare -A header_arguments


##
# Map for operation parameters passed after operation as PARAMETER=VALUE
# These will be mapped to appropriate path or query parameters
declare -A operation_parameters

##
# Map for body parameters passed after operation as PARAMETER:=VALUE
# These will be mapped to top level json keys ( {"PARAMETER": VALUE})
declare -A body_parameters

## 
# These arguments will be directly passed to cURL 
curl_arguments="{{curl-codegen-options}}"

##
# The host for making the request
host=""

##
# If true, the script will only output the actual cURL command that would be 
# used
print_curl=false

##
# The operation ID passed on the command line
operation=""

##
# The provided Accept header value
header_accept=""

##
# The provided Content-type header value
header_content_type=""

##
# If there is any body content on the stdin pass it to the body of the request
body_content_temp_file=""

##
# Declare some mime types abbreviations for easier content-type and accepts
# headers specification
declare -A mime_type_abbreviations
# text/*
mime_type_abbreviations["text"]="text/plain"
mime_type_abbreviations["html"]="text/html"
mime_type_abbreviations["md"]="text/x-markdown"
mime_type_abbreviations["csv"]="text/csv"
mime_type_abbreviations["css"]="text/css"
mime_type_abbreviations["rtf"]="text/rtf"
# application/*
mime_type_abbreviations["json"]="application/json"
mime_type_abbreviations["xml"]="application/xml"
mime_type_abbreviations["yaml"]="application/yaml"
mime_type_abbreviations["js"]="application/javascript"
mime_type_abbreviations["bin"]="application/octet-stream"
mime_type_abbreviations["rdf"]="application/rdf+xml"
# image/*
mime_type_abbreviations["jpg"]="image/jpeg"
mime_type_abbreviations["png"]="image/png"
mime_type_abbreviations["gif"]="image/gif"
mime_type_abbreviations["bmp"]="image/bmp"
mime_type_abbreviations["tiff"]="image/tiff"


##############################################################################
#
# Lookup the mime type abbreviation in the mime_type_abbreviations array.
# If not present assume the user provided a valid mime type
#
##############################################################################
function lookup_mime_type {
    local mime_type=$1

    if [[ ${mime_type_abbreviations[$mime_type]} ]]; then
        echo ${mime_type_abbreviations[$mime_type]}
    else
        echo $1
    fi
}

##############################################################################
#
# Converts an associative array into a list of cURL header
# arguments (-H "KEY: VALUE")
#
##############################################################################
function header_arguments_to_curl {
    local headers_curl=""
    for key in "${!header_arguments[@]}"; do
        headers_curl+="-H \"${key}: ${header_arguments[${key}]}\""
    done
    headers_curl+=" "
    echo "${headers_curl}"
}

##############################################################################
#
# Converts an associative array into a simple JSON with keys as top
# level object attributes
# 
# \todo Add convertion of more complex attributes using paths
#
##############################################################################
function body_parameters_to_json {
    local body_json="-d '{"
    local body_parameter_count=${#body_parameters[@]}
    local count=0
    for key in "${!body_parameters[@]}"; do
        body_json+="\"${key}\": ${body_parameters[${key}]}"
        if [[ $count -lt $body_parameter_count-1 ]]; then
            body_json+=", "
        fi
        count+=1
    done
    body_json+="}'"

    if [[ "${#body_parameters[@]}" -eq 0 ]]; then
        echo ""
    else
        echo "${body_json}"
    fi
}

##############################################################################
#
# Build request path including query parameters
#
##############################################################################
function build_request_path {
    local path_template=$1
    local -n path_params=$2
    local -n query_params=$3

    # First replace all path parameters in the path
    for pparam in "${path_params[@]}"; do
        regexp="(.*)(\{$pparam\})(.*)"
        if [[ $path_template =~ $regexp ]]; then
            path_template=${BASH_REMATCH[1]}${operation_parameters[$pparam]}${BASH_REMATCH[3]}
        fi
    done

    # Now append query parameters - if any
    if [[ ${#query_params[@]} -gt 0 ]]; then
        path_template+="?"
    fi

    local query_parameter_count=${#query_params[@]}
    local count=0
    for qparam in "${query_params[@]}"; do
        path_template+="${qparam}=${operation_parameters[${qparam}]}"
        if [[ $count -lt $query_parameter_count-1 ]]; then
            path_template+="&"
        fi
        count+=1
    done

    echo $path_template
}



###############################################################################
# 
# Print main help message
# 
###############################################################################
function print_help {
cat <<EOF

$(tput bold){{appName}} command line client (API version {{#swagger}}{{#info}}{{version}}{{/info}}{{/swagger}})$(tput sgr0)

$(tput bold)Usage$(tput sgr0)

$ ${script_name} [-h|--help] [-V|--version] [--about] [<curl-options>]
           --host <url> [--dry-run] <operation> [-h|--help] [<headers>] 
           [<parameters>]

  - <curl-options> - any valid cURL options can be passed before <operation>
  - <headers> - HTTP headers can be passed in the form HEADER:VALUE
  - <parameters> - REST operation parameters can be passed in the following 
                   forms:
                     * KEY=VALUE - path or query parameters
                     * KEY:=VALUE - body parameters which will be added to body 
                                    Json as '{ \"KEY\": \"VALUE\" }'
                     * KEY+=VALUE - body parameters which will be added to body 
                                    Json as '{ \"KEY\": VALUE }'

EOF
{{#hasAuthMethods}}
    echo -e "$(tput bold)Authentication methods$(tput sgr0)"
    echo -e ""
{{#authMethods}}
{{#isBasic}}
    echo -e "    - Basic AUTH (add '-u username:password' before <operation>)"
{{/isBasic}}
{{#isApiKey}}
    echo -e "    - Api-key (add '{{keyParamName}}:ACCESS_KEY' after <operation>)"
{{/isApiKey}}
{{#isOAuth}}
    echo -e "    - OAuth (url: {{authorizationUrl}})"
    echo -e "        Scopes:"
{{#scopes}}
    echo -e "          * {{scope}} - {{description}}"
{{/scopes}}
{{/isOAuth}}
{{/authMethods}}
    echo ""
{{/hasAuthMethods}}
    echo -e "$(tput bold)Operations$(tput sgr0)"
{{#apiInfo}}
{{#apis}}
    echo ""
    echo -e "$(tput bold)[{{classVarName}}]$(tput sgr0)"
read -d '' ops <<EOF
{{#operations}}
{{#operation}}
  {{operationId}};{{{summary}}}
{{/operation}}
{{/operations}}
EOF
echo "  $ops" | column -t -s ';'
{{/apis}}
{{/apiInfo}}
    echo ""
    echo -e "$(tput bold)Options$(tput sgr0)"
    echo -e "  -h,--help\t\t\t\tPrint this help"
    echo -e "  -V,--version\t\t\t\tPrint API version"
    echo -e "  --about\t\t\t\tPrint the information about service"
    echo -e "  --host <url>\t\t\t\tSpecify the host URL (e.g. "
    echo -e "              \t\t\t\t'https://{{#swagger}}{{host}}{{/swagger}}')"
    echo -e "  --dry-run\t\t\t\tPrint out the cURL command without"
    echo -e "           \t\t\t\texecuting it"
    echo -e "  -ac,--accept <mime-type>\t\tSet the accept header in the request"
    echo -e "  -ct,--content-type <mime-type>\tSet the content-type header in "
    echo -e "                                \tthe request"
    echo ""
}


##############################################################################
#
# Print REST service description
#
##############################################################################
function print_about {
    echo ""
    echo -e "$(tput bold){{appName}} command line client (API version {{#swagger}}{{#info}}{{version}}{{/info}}{{/swagger}})$(tput sgr0)"
    echo ""
read -d '' appdescription <<EOF
{{{appDescription}}}
EOF
echo "$appdescription" | fold -sw 80
}


##############################################################################
#
# Print REST api version
#
##############################################################################
function print_version {
    echo ""
    echo -e "$(tput bold){{appName}} command line client (API version {{#swagger}}{{#info}}{{version}}{{/info}}{{/swagger}})$(tput sgr0)"
    echo ""
}

{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
##############################################################################
#
# Print help for {{operationId}} operation
#
##############################################################################
function print_{{operationId}}_help {
    echo ""
    echo -e "$(tput bold){{{appName}}}  command line client$(tput sgr0)"
    echo ""
    echo -e "$(tput bold){{operationId}}$(tput sgr0) - {{{summary}}}"
    echo ""
    echo -e "$(tput bold)Parameters$(tput sgr0)"
{{#pathParams}}
    echo -e "  {{paramName}} [{{dataType}}] - {{{description}}}{{#required}} (required){{/required}}"
{{/pathParams}}
{{#queryParams}}
    echo -e "  {{paramName}} [{{dataType}}] - {{{description}}}{{#required}} (required){{/required}}"
{{/queryParams}}
{{#headerParams}}
    echo -e "  {{paramName}} [{{dataType}}] - {{{description}}}{{#required}} (required){{/required}}"
{{/headerParams}}
{{#hasConsumes}}
    echo ""
    echo -e "$(tput bold)Accepts (in body)$(tput sgr0)"
{{#consumes}}
    echo -e "  - {{{mediaType}}}"
{{/consumes}}
    echo ""
{{/hasConsumes}}
{{#bodyParams}}
    echo -e "  {{{description}}}{{#required}} (required){{/required}}"
{{/bodyParams}}
    echo -e ""
{{#bodyParams}}
{{#vendorExtensions}}
    echo -e "$(tput bold)Body content example$(tput sgr0)"
    echo -e ""
    echo -e '{{{x-codegen-body-example}}}'
    echo -e ""
{{/vendorExtensions}}
{{/bodyParams}}
}
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}


{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
##############################################################################
#
# Call {{operationId}} operation
#
##############################################################################
function call_{{operationId}} {
    local path_parameter_names=({{#pathParams}}{{baseName}}{{/pathParams}})
    local query_parameter_names=({{#queryParams}}{{baseName}}{{/queryParams}})

    local path=$(build_request_path "{{basePathWithoutHost}}{{path}}" path_parameter_names query_parameter_names)
    local method="{{httpMethod}}"
    local headers_curl=$(header_arguments_to_curl)

{{#hasBodyParam}}
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the 
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
{{#hasConsumes}}
{{#consumes}}
{{#-first}}
{{^hasMore}}
    if [[ -z $header_content_type ]]; then
        header_content_type="{{mediaType}}"
    fi
{{/hasMore}}
{{/-first}}
{{/consumes}}
{{/hasConsumes}}

{{#hasConsumes}}
    if [[ -z $header_content_type ]]; then
        echo "Error: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
{{#consumes}}
        echo -e "\t- {{mediaType}}"
{{/consumes}}
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi
{{/hasConsumes}}

    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY:=VALUE and KEY+=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
{{/hasBodyParam}}
{{^hasBodyParam}}
    if [[ "$print_curl" = true ]]; then
        echo ""
        echo "curl ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
{{/hasBodyParam}}
}

{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}


##############################################################################
#
# Main 
#
##############################################################################

# First, read any input (if available) from piped stdin as body content
# into a temporary file
if [[ -p /dev/stdin ]]; then
    body_content_temp_file=$(mktemp)
    cat - > $body_content_temp_file
fi

# Make sure Bash is at least in version 4.0
if [[ ${BASH_VERSION:0:1} < 4 ]]; then
    echo "Sorry - your Bash version is ${BASH_VERSION}"
    echo ""
    echo "You need at least Bash 4.0 to run this script."
    exit 1
fi


#
# Process command line
# 
# Pass all arguemnts before 'operation' to cURL except the ones we override
#
take_host=false
take_accept_header=false
take_contenttype_header=false

for key in "$@"; do
# Take the value of --host argument
if [[ "$take_host" = true ]]; then
    host="$key"
    take_host=false
    continue
fi
# Take the value of --accept argument
if [[ "$take_accept_header" = true ]]; then
    header_accept=$(lookup_mime_type "$key")
    take_accept_header=false
    continue
fi
# Take the value of --content-type argument
if [[ "$take_contenttype_header" = true ]]; then
    header_content_type=$(lookup_mime_type "$key")
    take_contenttype_header=false
    continue
fi
case $key in
    -h|--help)
    if [[ "x$operation" == "x" ]]; then
        print_help
        exit 0
    else
        eval "print_${operation}_help"
        exit 0
    fi
    ;;
    -V|--version)
    print_version
    exit 0
    ;;
    --about)
    print_about
    exit 0
    ;;
    --host)
    take_host=true
    ;;
    -ac|--accept)
    take_accept_header=true
    ;;
    -ct|--content-type)
    take_contenttype_header=true
    ;;    
    --dry-run)
    print_curl=true
    ;;   
{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
    {{operationId}})
    operation="{{operationId}}"
    ;;
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
    *:=*)
    # Parse body arguments and convert them into top level 
    # JSON properties passed in the body content as strings
    if [[ "$operation" ]]; then
        IFS=':=' read body_key sep body_value <<< "$key"
        body_parameters[${body_key}]="\"${body_value}\""
    fi
    ;;
    *+=*)
    # Parse body arguments and convert them into top level 
    # JSON properties passed in the body content as numeric values
    if [[ "$operation" ]]; then
        IFS='+=' read body_key sep body_value <<< "$key"
        body_parameters[${body_key}]=${body_value}
    fi
    ;;
    *:*)
    # Parse header arguments and convert them into curl
    # only after the operation argument
    if [[ "$operation" ]]; then
        IFS=':' read header_name header_value <<< "$key"
        header_arguments[$header_name]=$header_value
    else
        curl_arguments+=" $key"
    fi
    ;;
    *=*)
    # Parse operation arguments and convert them into curl
    # only after the operation argument
    if [[ "$operation" ]]; then
        IFS='=' read parameter_name parameter_value <<< "$key"
        operation_parameters[$parameter_name]=$parameter_value
    else
        curl_arguments+=" $key"
    fi
    ;;
    *)
    # If we are before the operation, treat the arguments as cURL arguments
    if [[ "x$operation" == "x" ]]; then
        # Maintain quotes around cURL arguments if necessary
        space_regexp="[[:space:]]"
        if [[ $key =~ $space_regexp ]]; then
            curl_arguments+=" \"$key\""
        else
            curl_arguments+=" $key"
        fi
    fi
    ;;
esac
done


# Check if user provided host name
if [[ -z "$host" ]]; then
    echo "Error: No hostname provided!!!"
    echo -e "Check usage: '${script_name} --help'"
    echo -e ""
    exit 1
fi

# Check if user specified operation ID
if [[ -z "$operation" ]]; then
    echo -e ""
    echo -e "No operation specified!"
    echo -e "Check available operations: '${script_name} --help'"
    echo -e ""
    exit 1
fi


# Run cURL command based on the operation ID
case $operation in
{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
    {{operationId}})
    call_{{operationId}}
    ;;
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
    *)
    echo "Unknown operation: $operation"
    echo ""
    print_help
    exit 1
esac

